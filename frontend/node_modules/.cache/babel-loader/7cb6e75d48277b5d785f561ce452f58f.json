{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Collider = void 0;\n\nvar Utils_1 = require(\"../../../../Utils\");\n\nvar Enums_1 = require(\"../../../../Enums\");\n\nvar Collider = function () {\n  function Collider() {}\n\n  Collider.collide = function (p1, container, _delta) {\n    var pos1 = p1.getPosition();\n    var query = container.particles.quadTree.query(new Utils_1.Circle(pos1.x, pos1.y, p1.size.value * 2));\n\n    for (var _i = 0, query_1 = query; _i < query_1.length; _i++) {\n      var p2 = query_1[_i];\n\n      if (p1 === p2 || !p2.particlesOptions.collisions.enable || p1.particlesOptions.collisions.mode !== p2.particlesOptions.collisions.mode) {\n        continue;\n      }\n\n      var pos2 = p2.getPosition();\n      var dist = Utils_1.Utils.getDistance(pos1, pos2);\n      var defaultSize = container.retina.sizeValue;\n      var radius1 = this.getRadius(p1, defaultSize);\n      var radius2 = this.getRadius(p2, defaultSize);\n      var distP = radius1 + radius2;\n\n      if (dist <= distP) {\n        this.resolveCollision(p1, p2);\n      }\n    }\n  };\n\n  Collider.getRadius = function (particle, fallback) {\n    return particle.bubble.radius || particle.size.value || fallback;\n  };\n\n  Collider.resolveCollision = function (p1, p2) {\n    var pos1 = p1.getPosition();\n    var pos2 = p2.getPosition();\n\n    switch (p1.particlesOptions.collisions.mode) {\n      case Enums_1.CollisionMode.bounce:\n        {\n          var xVelocityDiff = p1.velocity.horizontal - p2.velocity.horizontal;\n          var yVelocityDiff = p1.velocity.vertical - p2.velocity.vertical;\n          var xDist = pos2.x - pos1.x;\n          var yDist = pos2.y - pos1.y;\n\n          if (xVelocityDiff * xDist + yVelocityDiff * yDist >= 0) {\n            var angle = -Math.atan2(pos2.y - pos1.y, pos2.x - pos1.x);\n            var m1 = p1.size.value;\n            var m2 = p2.size.value;\n            var u1 = this.rotate(p1.velocity, angle);\n            var u2 = this.rotate(p2.velocity, angle);\n            var v1 = {\n              horizontal: u1.horizontal * (m1 - m2) / (m1 + m2) + u2.horizontal * 2 * m2 / (m1 + m2),\n              vertical: u1.vertical\n            };\n            var v2 = {\n              horizontal: u2.horizontal * (m1 - m2) / (m1 + m2) + u1.horizontal * 2 * m2 / (m1 + m2),\n              vertical: u2.vertical\n            };\n            var vFinal1 = this.rotate(v1, -angle);\n            var vFinal2 = this.rotate(v2, -angle);\n            p1.velocity.horizontal = vFinal1.horizontal;\n            p1.velocity.vertical = vFinal1.vertical;\n            p2.velocity.horizontal = vFinal2.horizontal;\n            p2.velocity.vertical = vFinal2.vertical;\n          }\n        }\n    }\n  };\n\n  Collider.rotate = function (velocity, angle) {\n    return {\n      horizontal: velocity.horizontal * Math.cos(angle) - velocity.vertical * Math.sin(angle),\n      vertical: velocity.horizontal * Math.sin(angle) + velocity.vertical * Math.cos(angle)\n    };\n  };\n\n  return Collider;\n}();\n\nexports.Collider = Collider;","map":{"version":3,"sources":["/Users/guru/Desktop/Development/React/smartbrain/node_modules/tsparticles/dist/Core/Particle/Interactions/Particles/Collider.js"],"names":["Object","defineProperty","exports","value","Collider","Utils_1","require","Enums_1","collide","p1","container","_delta","pos1","getPosition","query","particles","quadTree","Circle","x","y","size","_i","query_1","length","p2","particlesOptions","collisions","enable","mode","pos2","dist","Utils","getDistance","defaultSize","retina","sizeValue","radius1","getRadius","radius2","distP","resolveCollision","particle","fallback","bubble","radius","CollisionMode","bounce","xVelocityDiff","velocity","horizontal","yVelocityDiff","vertical","xDist","yDist","angle","Math","atan2","m1","m2","u1","rotate","u2","v1","v2","vFinal1","vFinal2","cos","sin"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Collider = void 0;\nvar Utils_1 = require(\"../../../../Utils\");\nvar Enums_1 = require(\"../../../../Enums\");\nvar Collider = (function () {\n    function Collider() {\n    }\n    Collider.collide = function (p1, container, _delta) {\n        var pos1 = p1.getPosition();\n        var query = container.particles.quadTree.query(new Utils_1.Circle(pos1.x, pos1.y, p1.size.value * 2));\n        for (var _i = 0, query_1 = query; _i < query_1.length; _i++) {\n            var p2 = query_1[_i];\n            if (p1 === p2 ||\n                !p2.particlesOptions.collisions.enable ||\n                p1.particlesOptions.collisions.mode !== p2.particlesOptions.collisions.mode) {\n                continue;\n            }\n            var pos2 = p2.getPosition();\n            var dist = Utils_1.Utils.getDistance(pos1, pos2);\n            var defaultSize = container.retina.sizeValue;\n            var radius1 = this.getRadius(p1, defaultSize);\n            var radius2 = this.getRadius(p2, defaultSize);\n            var distP = radius1 + radius2;\n            if (dist <= distP) {\n                this.resolveCollision(p1, p2);\n            }\n        }\n    };\n    Collider.getRadius = function (particle, fallback) {\n        return particle.bubble.radius || particle.size.value || fallback;\n    };\n    Collider.resolveCollision = function (p1, p2) {\n        var pos1 = p1.getPosition();\n        var pos2 = p2.getPosition();\n        switch (p1.particlesOptions.collisions.mode) {\n            case Enums_1.CollisionMode.bounce: {\n                var xVelocityDiff = p1.velocity.horizontal - p2.velocity.horizontal;\n                var yVelocityDiff = p1.velocity.vertical - p2.velocity.vertical;\n                var xDist = pos2.x - pos1.x;\n                var yDist = pos2.y - pos1.y;\n                if (xVelocityDiff * xDist + yVelocityDiff * yDist >= 0) {\n                    var angle = -Math.atan2(pos2.y - pos1.y, pos2.x - pos1.x);\n                    var m1 = p1.size.value;\n                    var m2 = p2.size.value;\n                    var u1 = this.rotate(p1.velocity, angle);\n                    var u2 = this.rotate(p2.velocity, angle);\n                    var v1 = {\n                        horizontal: (u1.horizontal * (m1 - m2)) / (m1 + m2) + (u2.horizontal * 2 * m2) / (m1 + m2),\n                        vertical: u1.vertical,\n                    };\n                    var v2 = {\n                        horizontal: (u2.horizontal * (m1 - m2)) / (m1 + m2) + (u1.horizontal * 2 * m2) / (m1 + m2),\n                        vertical: u2.vertical,\n                    };\n                    var vFinal1 = this.rotate(v1, -angle);\n                    var vFinal2 = this.rotate(v2, -angle);\n                    p1.velocity.horizontal = vFinal1.horizontal;\n                    p1.velocity.vertical = vFinal1.vertical;\n                    p2.velocity.horizontal = vFinal2.horizontal;\n                    p2.velocity.vertical = vFinal2.vertical;\n                }\n            }\n        }\n    };\n    Collider.rotate = function (velocity, angle) {\n        return {\n            horizontal: velocity.horizontal * Math.cos(angle) - velocity.vertical * Math.sin(angle),\n            vertical: velocity.horizontal * Math.sin(angle) + velocity.vertical * Math.cos(angle),\n        };\n    };\n    return Collider;\n}());\nexports.Collider = Collider;\n"]},"metadata":{},"sourceType":"script"}